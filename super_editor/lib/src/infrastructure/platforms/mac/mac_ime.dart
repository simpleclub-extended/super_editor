import 'package:flutter/widgets.dart';

/// MacOS selector names that are sent to [TextInputClient.performSelector].
///
/// These selectors express the user intent and are generated by shortcuts. For example,
/// pressing SHIFT + Left Arrow key generates a moveLeftAndModifySelection selector.
///
/// The full list can be found on https://developer.apple.com/documentation/appkit/nsstandardkeybindingresponding?changes=_8&language=objc
class MacOsSelectors {
  static const String deleteBackward = 'deleteBackward:';
  static const String deleteWordBackward = 'deleteWordBackward:';
  static const String deleteToBeginningOfLine = 'deleteToBeginningOfLine:';
  static const String deleteForward = 'deleteForward:';
  static const String deleteWordForward = 'deleteWordForward:';
  static const String deleteToEndOfLine = 'deleteToEndOfLine:';
  static const String deleteBackwardByDecomposingPreviousCharacter = 'deleteBackwardByDecomposingPreviousCharacter:';

  static const String moveLeft = 'moveLeft:';
  static const String moveRight = 'moveRight:';
  static const String moveForward = 'moveForward:';
  static const String moveBackward = 'moveBackward:';
  static const String moveUp = 'moveUp:';
  static const String moveDown = 'moveDown:';

  static const String moveWordLeft = 'moveWordLeft:';
  static const String moveWordRight = 'moveWordRight:';
  static const String moveToBeginningOfParagraph = 'moveToBeginningOfParagraph:';
  static const String moveToEndOfParagraph = 'moveToEndOfParagraph:';

  static const String moveToLeftEndOfLine = 'moveToLeftEndOfLine:';
  static const String moveToRightEndOfLine = 'moveToRightEndOfLine:';
  static const String moveToBeginningOfDocument = 'moveToBeginningOfDocument:';
  static const String moveToEndOfDocument = 'moveToEndOfDocument:';

  static const String moveLeftAndModifySelection = 'moveLeftAndModifySelection:';
  static const String moveRightAndModifySelection = 'moveRightAndModifySelection:';
  static const String moveUpAndModifySelection = 'moveUpAndModifySelection:';
  static const String moveDownAndModifySelection = 'moveDownAndModifySelection:';

  static const String moveWordLeftAndModifySelection = 'moveWordLeftAndModifySelection:';
  static const String moveWordRightAndModifySelection = 'moveWordRightAndModifySelection:';
  static const String moveParagraphBackwardAndModifySelection = 'moveParagraphBackwardAndModifySelection:';
  static const String moveParagraphForwardAndModifySelection = 'moveParagraphForwardAndModifySelection:';

  static const String moveToLeftEndOfLineAndModifySelection = 'moveToLeftEndOfLineAndModifySelection:';
  static const String moveToRightEndOfLineAndModifySelection = 'moveToRightEndOfLineAndModifySelection:';
  static const String moveToBeginningOfDocumentAndModifySelection = 'moveToBeginningOfDocumentAndModifySelection:';
  static const String moveToEndOfDocumentAndModifySelection = 'moveToEndOfDocumentAndModifySelection:';

  static const String transpose = 'transpose:';

  static const String scrollToBeginningOfDocument = 'scrollToBeginningOfDocument:';
  static const String scrollToEndOfDocument = 'scrollToEndOfDocument:';

  static const String scrollPageUp = 'scrollPageUp:';
  static const String scrollPageDown = 'scrollPageDown:';
  static const String pageUpAndModifySelection = 'pageUpAndModifySelection:';
  static const String pageDownAndModifySelection = 'pageDownAndModifySelection:';

  static const String cancelOperation = 'cancelOperation:';

  static const String insertTab = 'insertTab:';
  static const String insertBacktab = 'insertBacktab:';
  static const String insertNewLine = 'insertNewline:';
}

/// Stop propagating intents that prevent [TextInputClient.performSelector] from being called.
///
/// These intents have default handlers installed by Flutter
/// that prevents the key events from bubbling up to the IME.
///
/// Use this object in an [Actions] widget.
final Map<Type, Action<Intent>> disabledMacIntents = {
  // Generated by pressing LEFT/RIGHT ARROW.
  ExtendSelectionByCharacterIntent: DoNothingAction(consumesKey: false),

  // Generated by pressing UP/DOWN ARROW.
  ExtendSelectionVerticallyToAdjacentLineIntent: DoNothingAction(consumesKey: false),

  // Generated by pressing PAGE UP/DOWN.
  ScrollIntent: DoNothingAction(consumesKey: false),

  // Generated by pressing HOME/END.
  ScrollToDocumentBoundaryIntent: DoNothingAction(consumesKey: false),

  // Generated by pressing TAB.
  NextFocusIntent: DoNothingAction(consumesKey: false),

  // Generated by pressing SHIFT + TAB.
  PreviousFocusIntent: DoNothingAction(consumesKey: false),

  // Generated by pressing SPACE.
  // PrioritizedIntents might contain intents that we don't want to prevent
  // from bubbling up.
  // So, we need to look into its inner intents.
  PrioritizedIntents: _PreventPrioritizedIntentsFromBubblingUp(
    intentFilter: (e) => e is ActivateIntent,
  ),
};

/// Prevents a [PrioritizedIntents] from bubbling up if [intentFilter] returns
/// `true` for at least one of its `orderedIntents`.
///
/// Based on [PrioritizedAction].
class _PreventPrioritizedIntentsFromBubblingUp extends Action<PrioritizedIntents> {
  _PreventPrioritizedIntentsFromBubblingUp({
    required this.intentFilter,
  });

  /// Whether the [intent] should be prevented from bubbling up.
  final bool Function(Intent intent) intentFilter;

  @override
  bool consumesKey(Intent intent) => false;

  @override
  void invoke(Intent intent) {}

  @override
  bool isEnabled(PrioritizedIntents intent, [BuildContext? context]) {
    final FocusNode? focus = primaryFocus;
    if (focus == null || focus.context == null) {
      return false;
    }

    for (final Intent candidateIntent in intent.orderedIntents) {
      final Action<Intent>? candidateAction = Actions.maybeFind<Intent>(
        focus.context!,
        intent: candidateIntent,
      );
      if (candidateAction != null && _isActionEnabled(candidateAction, candidateIntent, context)) {
        // The corresponding Action for the Intent is enabled.
        // This is the Action that Flutter will execute.
        if (intentFilter(candidateIntent)) {
          return true;
        }

        // We don't care about the Intent that is going to have its corresponding Action executed.
        // Don't block it.
        return false;
      }
    }

    return false;
  }

  bool _isActionEnabled(Action action, Intent intent, BuildContext? context) {
    if (action is ContextAction<Intent>) {
      return action.isEnabled(intent, context);
    }
    return action.isEnabled(intent);
  }
}
